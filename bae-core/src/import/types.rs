//! Import type definitions
//!
//! # Import Architecture
//!
//! All imports follow the same data flow, regardless of whether tracks are stored as
//! individual files (one-file-per-track) or as a single file with a CUE sheet (one-file-per-album):
//!
//! ## Phase 1: Track-to-File Mapping (Validation)
//! - Map logical tracks (from Discogs metadata) to physical audio files (from user's folder)
//! - Validates that the user's files match the expected album structure
//! - For one-file-per-track: Each logical track maps to its own file (01.flac, 02.flac, etc.)
//! - For CUE/FLAC: All logical tracks map to the same FLAC file, CUE sheet parsed for validation
//! - Output: `TrackToFileMappingResult` (track→file mappings + optional CUE metadata)
//!
//! ## Phase 2: File Storage
//! - Store files to local disk or cloud storage
//! - Optionally encrypt files before storage
//! - Track progress by bytes written
//!
//! ## Phase 3: Metadata Persistence
//! - Store file records with storage paths
//! - Store track audio format records
#[cfg(feature = "cd-rip")]
use crate::cd::drive::CdToc;
#[cfg(feature = "cd-rip")]
use crate::db::DbTrack;
#[cfg(feature = "torrent")]
use crate::import::handle::TorrentImportMetadata;
use crate::{
    cue_flac::CueSheet,
    db::{DbAlbum, DbRelease},
    discogs::DiscogsRelease,
    musicbrainz::MbRelease,
};
use std::{collections::HashMap, path::PathBuf};

/// User's cover art selection for an import.
#[derive(Clone, Debug)]
pub enum CoverSelection {
    /// Remote cover to download (URL)
    Remote(String),
    /// Local file in the album folder (relative path from album root)
    Local(String),
}

/// Request to import an album
#[derive(Debug)]
pub enum ImportRequest {
    Folder {
        /// Unique ID for this import operation (generated by UI for progress tracking)
        import_id: String,
        discogs_release: Option<DiscogsRelease>,
        mb_release: Option<MbRelease>,
        folder: PathBuf,
        master_year: u32,
        /// Storage profile ID. None means no bae storage (files stay in place).
        storage_profile_id: Option<String>,
        /// User-selected cover image.
        selected_cover: Option<CoverSelection>,
    },
    #[cfg(feature = "torrent")]
    Torrent {
        torrent_source: TorrentSource,
        discogs_release: Option<DiscogsRelease>,
        mb_release: Option<MbRelease>,
        master_year: u32,
        seed_after_download: bool,
        torrent_metadata: TorrentImportMetadata,
        /// Storage profile ID. None means no bae storage (files stay in temp folder).
        storage_profile_id: Option<String>,
        /// User-selected cover image.
        selected_cover: Option<CoverSelection>,
    },
    #[cfg(feature = "cd-rip")]
    CD {
        discogs_release: Option<DiscogsRelease>,
        mb_release: Option<MbRelease>,
        drive_path: PathBuf,
        master_year: u32,
        /// Storage profile ID. None means no bae storage (files stay in temp folder).
        storage_profile_id: Option<String>,
        /// User-selected cover image.
        selected_cover: Option<CoverSelection>,
    },
}

/// Source for torrent import
#[cfg(feature = "torrent")]
#[derive(Debug, Clone)]
pub enum TorrentSource {
    File(PathBuf),
    MagnetLink(String),
}

/// Progress updates during import
#[derive(Debug, Clone)]
pub enum ImportProgress {
    /// Phase 0: Preparation steps (emitted from ImportHandle before pipeline starts)
    Preparing {
        import_id: String,
        step: PrepareStep,
        album_title: String,
        artist_name: String,
        cover_art_url: Option<String>,
    },
    Started {
        id: String,
        import_id: Option<String>,
    },
    Progress {
        id: String,
        percent: u8,
        /// Phase of import: Acquire (data fetching) or Store (storage/encryption)
        /// - Folder imports: Only Store phase (acquire is instant)
        /// - Torrent imports: Acquire phase (download), then Store phase (storage)
        /// - CD imports: Acquire phase (rip), then Store phase (storage)
        phase: Option<ImportPhase>,
        import_id: Option<String>,
    },
    Complete {
        id: String,
        /// For track completions, this is the parent release ID (for filtering)
        /// For release completions, this is None
        release_id: Option<String>,
        import_id: Option<String>,
    },
    Failed {
        id: String,
        error: String,
        import_id: Option<String>,
    },
}

/// Phase of import process (applies to all import types)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ImportPhase {
    /// Acquire phase: Get data ready for import
    /// - Folder: No-op (files already available)
    /// - Torrent: Download torrent to temporary folder
    /// - CD: Rip CD tracks to FLAC files
    Acquire,
    /// Store phase: Store and encrypt data
    /// Same for all import types: read files → encrypt → store
    Store,
}

/// Steps during phase 0 preparation (in ImportHandle, before pipeline starts)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PrepareStep {
    ParsingMetadata,
    DownloadingCoverArt,
    DiscoveringFiles,
    ValidatingTracks,
    SavingToDatabase,
    ExtractingDurations,
}

impl PrepareStep {
    /// Human-readable display text for UI
    pub fn display_text(&self) -> &'static str {
        match self {
            PrepareStep::ParsingMetadata => "Parsing metadata...",
            PrepareStep::DownloadingCoverArt => "Downloading cover art...",
            PrepareStep::DiscoveringFiles => "Discovering files...",
            PrepareStep::ValidatingTracks => "Validating tracks...",
            PrepareStep::SavingToDatabase => "Saving to database...",
            PrepareStep::ExtractingDurations => "Extracting durations...",
        }
    }
}

/// Maps a logical track to its physical audio file.
///
/// Links a track from album metadata (e.g., Discogs) to an audio file provided by the user.
///
/// Mapping types:
/// - **One-file-per-track**: Each logical track maps to its own file (e.g., "01.flac", "02.flac")
/// - **CUE/FLAC**: Multiple logical tracks map to the same FLAC file (e.g., all tracks → "album.flac")
#[derive(Debug, Clone)]
pub struct TrackFile {
    /// Database track ID (UUID) - represents the logical track from metadata
    pub db_track_id: String,
    /// Path to the physical audio file containing this track's audio data
    pub file_path: PathBuf,
}

/// Output of track validation: Validated mapping of logical tracks to physical files.
///
/// Links logical tracks (from album metadata) to physical files (from user's folder).
/// Both import types produce these mappings. CUE/FLAC imports additionally include
/// parsed CUE sheet data to avoid re-parsing in later phases.
#[derive(Debug, Clone)]
pub struct TrackToFileMappingResult {
    /// Logical track → physical file mappings (always populated)
    pub track_files: Vec<TrackFile>,
    /// Parsed CUE/FLAC metadata (only for CUE/FLAC imports)
    /// Key: FLAC file path
    /// None for one-file-per-track imports
    pub cue_flac_metadata: Option<HashMap<PathBuf, CueFlacMetadata>>,
}

/// Pre-parsed CUE/FLAC metadata from the track mapping phase.
/// Parsed once during validation, then passed through to avoid re-parsing.
#[derive(Debug, Clone)]
pub struct CueFlacMetadata {
    /// Parsed CUE sheet with track timing and metadata
    pub cue_sheet: CueSheet,
    /// Path to the CUE file
    pub cue_path: PathBuf,
    /// Path to the FLAC file
    pub flac_path: PathBuf,
}

/// A file discovered during folder scan.
///
/// All files in the album folder are discovered and their sizes recorded.
/// This includes audio files, CUE sheets, cover art, and other metadata files.
#[derive(Clone, Debug)]
pub struct DiscoveredFile {
    pub path: PathBuf,
    pub size: u64,
}

/// Validated import command ready for execution.
///
/// All imports follow a two-phase model:
/// - **Acquire phase**: Get data ready (folder: no-op, torrent: download, CD: rip)
/// - **Store phase**: Store and encrypt (same for all types)
///
/// Handle only validates and sends commands. Service executes both phases.
#[derive(Debug)]
pub enum ImportCommand {
    /// Folder-based import: all files available upfront
    Folder {
        /// Database album record
        db_album: DbAlbum,
        /// Database release record
        db_release: DbRelease,
        /// Logical track → physical file mappings
        tracks_to_files: Vec<TrackFile>,
        /// Files discovered during folder scan
        discovered_files: Vec<DiscoveredFile>,
        /// Pre-parsed CUE/FLAC metadata (for CUE/FLAC imports only)
        cue_flac_metadata: Option<HashMap<PathBuf, CueFlacMetadata>>,
        /// Storage profile ID. None means no bae storage (files stay in place).
        storage_profile_id: Option<String>,
        /// Resolved absolute path to a local cover image file
        cover_image_path: Option<PathBuf>,
        /// Whether a remote cover was already downloaded and cached by the handle
        remote_cover_set: bool,
        /// Import operation ID for progress tracking
        import_id: String,
    },
    /// Torrent-based import: files arrive incrementally
    #[cfg(feature = "torrent")]
    Torrent {
        /// Database album record
        db_album: DbAlbum,
        /// Database release record
        db_release: DbRelease,
        /// Logical track → physical file mappings
        tracks_to_files: Vec<TrackFile>,
        /// Torrent source (stored to recreate handle in import service)
        /// We can't send TorrentClient/TorrentHandle through channels as they contain UniquePtr
        torrent_source: TorrentSource,
        /// Torrent-specific metadata
        torrent_metadata: TorrentImportMetadata,
        /// Whether to start seeding after download completes
        seed_after_download: bool,
        /// Storage profile ID. None means no bae storage (files stay in temp folder).
        storage_profile_id: Option<String>,
        /// User-selected cover (resolved after torrent download)
        selected_cover: Option<CoverSelection>,
    },
    /// CD-based import: service will rip CD first (acquire phase), then process like folder import
    #[cfg(feature = "cd-rip")]
    CD {
        /// Database album record
        db_album: DbAlbum,
        /// Database release record
        db_release: DbRelease,
        /// Database tracks (for mapping after ripping)
        db_tracks: Vec<DbTrack>,
        /// CD drive path
        drive_path: PathBuf,
        /// CD TOC (Table of Contents) - read during validation
        toc: CdToc,
        /// Storage profile ID. None means no bae storage (files stay in temp folder).
        storage_profile_id: Option<String>,
        /// Resolved absolute path to the cover image file
        cover_image_path: Option<PathBuf>,
    },
}
