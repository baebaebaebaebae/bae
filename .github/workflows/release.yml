name: Release

on:
  workflow_dispatch:
    inputs:
      commit:
        description: 'Commit SHA to release (leave blank for HEAD)'
        required: false
        default: ''

concurrency:
  group: release
  cancel-in-progress: false

env:
  CARGO_TERM_COLOR: always

jobs:
  calculate-version:
    name: Calculate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.calc.outputs.version }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ inputs.commit || github.sha }}

    - name: Verify commit passed CI
      run: |
        COMMIT="${{ inputs.commit || github.sha }}"
        
        # Check GitHub Actions check runs, filtering to only CI workflow (Test + Security)
        # Exclude Release workflow checks to avoid checking ourselves
        CHECKS=$(gh api repos/${{ github.repository }}/commits/${COMMIT}/check-runs --jq '
          .check_runs | [.[] | select(.name | test("^Test|^Security"))]
        ')
        TOTAL=$(echo "$CHECKS" | jq 'length')
        
        if [[ "$TOTAL" == "0" ]]; then
          echo "::error::No CI checks found for commit ${COMMIT}"
          echo "::error::Push this commit and wait for CI to pass before releasing."
          exit 1
        fi
        
        # Check if any are still in progress
        IN_PROGRESS=$(echo "$CHECKS" | jq '[.[] | select(.status != "completed")] | length')
        if [[ "$IN_PROGRESS" != "0" ]]; then
          echo "::error::CI is still running for commit ${COMMIT}"
          exit 1
        fi
        
        # Check if any failed (conclusion is not success/skipped)
        FAILED=$(echo "$CHECKS" | jq '[.[] | select(.conclusion != "success" and .conclusion != "skipped")] | length')
        if [[ "$FAILED" != "0" ]]; then
          echo "::error::CI failed for commit ${COMMIT}"
          echo "$CHECKS" | jq '.[] | select(.conclusion != "success" and .conclusion != "skipped") | {name, conclusion}'
          exit 1
        fi
        
        echo "::notice::Commit ${COMMIT} has passed CI ($TOTAL checks)"
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Calculate next version from tags and date
      id: calc
      run: |
        YEAR=$(date +%Y)
        MONTH=$(date +%-m)
        
        # Get latest tag for this year.month
        LATEST=$(git tag -l "v${YEAR}.${MONTH}.*" | sort -V | tail -1)
        
        if [[ -z "$LATEST" ]]; then
          # First release this month
          VERSION="${YEAR}.${MONTH}.0"
        else
          # Increment patch from latest tag
          PATCH=$(echo "$LATEST" | sed "s/v${YEAR}\.${MONTH}\.\([0-9]*\)/\1/")
          VERSION="${YEAR}.${MONTH}.$((PATCH + 1))"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "::notice::Next version will be $VERSION"

  release:
    name: Build and Release
    runs-on: macos-latest
    needs: [calculate-version]
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.commit || github.sha }}

    - name: Install macOS dependencies
      run: |
        brew install libdiscid libcdio libsodium pkg-config libtorrent-rasterbar boost ffmpeg

    - name: Install Rust (uses rust-toolchain.toml)
      run: rustup show

    - name: Cache Rust dependencies
      uses: Swatinem/rust-cache@v2
      with:
        workspaces: bae -> target
        shared-key: rust-cache
        cache-directories: ~/.cargo/bin

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: |
          bae/package-lock.json
          website/package-lock.json

    - name: Install Node dependencies (app)
      working-directory: ./bae
      run: npm ci

    - name: Install Node dependencies (website)
      working-directory: ./website
      run: npm ci

    - name: Install Dioxus CLI
      run: |
        if ! command -v dx &> /dev/null; then
          cargo install dioxus-cli
        fi

    - name: Set release version
      run: |
        VERSION="${{ needs.calculate-version.outputs.version }}"
        echo "BAE_VERSION=$VERSION" >> $GITHUB_ENV
        # Patch Cargo.toml for bundle metadata (not committed)
        sed -i '' "s/^version = .*/version = \"$VERSION\"/" bae/Cargo.toml
        echo "Building version $VERSION"

    - name: Build app bundle
      working-directory: ./bae
      run: |
        if [[ -d "/opt/homebrew" ]]; then
          export PKG_CONFIG_PATH="/opt/homebrew/lib/pkgconfig"
          export LIBRARY_PATH="/opt/homebrew/lib"
          export BINDGEN_EXTRA_CLANG_ARGS="-I/opt/homebrew/include"
        else
          export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig"
          export LIBRARY_PATH="/usr/local/lib"
          export BINDGEN_EXTRA_CLANG_ARGS="-I/usr/local/include"
        fi
        dx bundle --release

    - name: Bundle dylibs into app
      working-directory: ./bae
      run: ./scripts/bundle_dylibs.sh target/dx/bae/bundle/macos/bundle/macos/bae.app

    - name: Upload unsigned build (backup)
      uses: actions/upload-artifact@v4
      with:
        name: bae-macOS-unsigned
        path: bae/target/dx/bae/bundle/macos/bundle/macos/bae.app
        retention-days: 7

    - name: Import Apple certificate
      env:
        APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
        APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
      run: |
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
        
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        
        echo "$APPLE_CERTIFICATE" | base64 --decode > $RUNNER_TEMP/certificate.p12
        security import $RUNNER_TEMP/certificate.p12 -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
        security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security list-keychain -d user -s "$KEYCHAIN_PATH"

    - name: Sign app bundle
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        APP_PATH="bae/target/dx/bae/bundle/macos/bundle/macos/bae.app"
        IDENTITY=$(security find-identity -v -p codesigning | grep "$APPLE_TEAM_ID" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        echo "Using signing identity: $IDENTITY"
        
        codesign --deep --force --verify --verbose \
          --sign "$IDENTITY" \
          --options runtime \
          "$APP_PATH"
        
        codesign --verify --verbose "$APP_PATH"

    - name: Create signed DMG
      env:
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        APP_PATH="bae/target/dx/bae/bundle/macos/bundle/macos/bae.app"
        DMG_PATH="bae/target/bae.dmg"
        IDENTITY=$(security find-identity -v -p codesigning | grep "$APPLE_TEAM_ID" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        
        # Create temporary directory for DMG contents
        DMG_TEMP=$(mktemp -d)
        trap "rm -rf $DMG_TEMP" EXIT
        
        # Copy app bundle to temp directory
        cp -R "$APP_PATH" "$DMG_TEMP/"
        
        # Create Applications folder symlink
        ln -s /Applications "$DMG_TEMP/Applications"
        
        # Create DMG from temp directory
        hdiutil create -volname "bae" -srcfolder "$DMG_TEMP" -ov -format UDZO "$DMG_PATH"
        codesign --force --sign "$IDENTITY" "$DMG_PATH"

    - name: Notarize DMG
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        DMG_PATH="bae/target/bae.dmg"
        
        xcrun notarytool submit "$DMG_PATH" \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_APP_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --wait
        
        xcrun stapler staple "$DMG_PATH"

    - name: Generate screenshots
      working-directory: ./bae
      env:
        BAE_SCREENSHOT_FIXTURES_DIR: ../website/fixtures/screenshots
        BAE_SCREENSHOT_OUTPUT_DIR: ../website/public/screenshots
      run: |
        if [[ -d "/opt/homebrew" ]]; then
          export PKG_CONFIG_PATH="/opt/homebrew/lib/pkgconfig"
          export LIBRARY_PATH="/opt/homebrew/lib"
        else
          export PKG_CONFIG_PATH="/usr/local/lib/pkgconfig"
          export LIBRARY_PATH="/usr/local/lib"
        fi
        cargo run --release --bin generate_screenshots

    - name: Upload screenshots
      uses: actions/upload-artifact@v4
      with:
        name: website-screenshots
        path: website/public/screenshots/
        retention-days: 1

    - name: Create git tag
      run: |
        VERSION="${{ needs.calculate-version.outputs.version }}"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag "v$VERSION"
        git push origin "v$VERSION"

    - name: Upload signed DMG
      uses: actions/upload-artifact@v4
      with:
        name: bae-macOS-signed
        path: bae/target/bae.dmg
        retention-days: 30

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ needs.calculate-version.outputs.version }}
        files: bae/target/bae.dmg
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy-website:
    name: Deploy Website
    needs: [release]
    uses: ./.github/workflows/deploy-website.yml
    with:
      screenshots_artifact: website-screenshots
    secrets: inherit
