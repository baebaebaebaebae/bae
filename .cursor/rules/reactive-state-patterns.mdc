# Reactive State Patterns

## Core Principle: Pass Lenses Down, Read at Leaf

Never call `.read()` until you actually need to render a value. Pass the signal down through the component tree, and only read at the leaf level.

```rust
// Good: pass signal down, read at leaf
fn Parent(state: ReadSignal<AppState>) {
    rsx! { Child { state } }  // just pass it through
}

fn Child(state: ReadSignal<AppState>) {
    let value = state.read().some_field;  // read at leaf when rendering
    rsx! { div { "{value}" } }
}

// Bad: read in parent, pass value down
fn Parent(state: ReadSignal<AppState>) {
    let value = state.read().some_field;  // parent re-renders!
    rsx! { Child { value } }
}
```

## Why This Matters

When you call `.read()`, that component subscribes to ALL changes to the signal - not just the fields you access. Dioxus can't track field-level access.

So if you read in a parent and pass values down, the entire parent subtree re-renders on any state change. If you pass the signal down and read at the leaf, only the leaf re-renders.

## AppState is the Single Source of Truth

All application state lives in `AppState` (a Dioxus Store). Access nested state via lenses:

```rust
let profiles = app.state.storage_profiles().profiles();
MyComponent { profiles }  // pass lens down
```

## Import Store Extension Traits

When using lens methods generated by `#[derive(Store)]`, import the extension trait:

```rust
use bae_ui::stores::{AppStateStoreExt, StorageProfilesStateStoreExt};
```

## Don't Create Duplicate Display Types

If you need a subset of fields, just use the full type. Don't create `FooInfo` variants of `Foo`:

```rust
// Bad
struct StorageProfileInfo { id, name, is_default }

// Good - just use the full type, ignore extra fields
struct StorageProfile { id, name, location, encrypted, is_default, ... }
```
